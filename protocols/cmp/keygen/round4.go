package keygen

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/taurusgroup/multi-party-sig/internal/jsontools"
	"github.com/taurusgroup/multi-party-sig/internal/round"
	"github.com/taurusgroup/multi-party-sig/internal/types"
	"github.com/taurusgroup/multi-party-sig/pkg/math/curve"
	"github.com/taurusgroup/multi-party-sig/pkg/math/polynomial"
	"github.com/taurusgroup/multi-party-sig/pkg/paillier"
	"github.com/taurusgroup/multi-party-sig/pkg/party"
	zkfac "github.com/taurusgroup/multi-party-sig/pkg/zk/fac"
	zkmod "github.com/taurusgroup/multi-party-sig/pkg/zk/mod"
	zkprm "github.com/taurusgroup/multi-party-sig/pkg/zk/prm"
	"github.com/taurusgroup/multi-party-sig/protocols/cmp/config"
)

var _ round.Round = (*Kround4)(nil)

type Kround4 struct {
	*Kround3

	// RID = ⊕ⱼ RIDⱼ
	// Random ID generated by taking the XOR of all ridᵢ
	RID types.RID
	// ChainKey is a sequence of random bytes agreed upon together
	ChainKey types.RID
}

type Message4 struct {
	// Share = Encᵢ(x) is the encryption of the receivers share
	Share *paillier.Ciphertext
	Fac   *zkfac.Proof
}

type Broadcast4 struct {
	round.NormalBroadcastContent
	Mod *zkmod.Proof
	Prm *zkprm.Proof
	Fac *zkfac.Proof
}

// StoreBroadcastMessage implements round.BroadcastRound.
//
// - verify Mod, Prm proof for N
func (r *Kround4) StoreBroadcastMessage(msg round.Message) error {
	from := msg.From
	body, ok := msg.Content.(*Broadcast4)
	if !ok || body == nil {
		fmt.Printf("Round content invalid: %+v\n", body)
		return round.ErrInvalidContent
	}

	// verify zkmod
	if !body.Mod.Verify(zkmod.Public{N: r.Pedersen[from].N()}, r.HashForID(from), nil) {
		fmt.Printf("Kr4.StoreBroadcastMessage(): Failed to validate zkmod\n")
		return errors.New("failed to validate mod proof")
	}

	// verify zkprm
	if !body.Prm.Verify(zkprm.Public{Aux: r.Pedersen[from]}, r.HashForID(from), nil) {
		fmt.Printf("Kr4.StoreBroadcastMessage(): Failed to validate zkprm\n")
		return errors.New("failed to validate prm proof")
	}
	return nil
}

// VerifyMessage implements round.Round.
//
// - verify validity of share ciphertext.
func (r *Kround4) VerifyMessage(msg round.Message) error {
	from := msg.From
	body, ok := msg.Content.(*Message4)
	if !ok || body == nil {
		return round.ErrInvalidContent
	}

	if !r.PaillierPublic[msg.To].ValidateCiphertexts(body.Share) {
		fmt.Printf("Kr4 VerifyMessage() failed; invalid ciphertext\n")
		return errors.New("invalid ciphertext")
	}

	// verify zkfac
	if !body.Fac.Verify(zkfac.Public{N: r.PaillierPublic[from].N(), Aux: r.Pedersen[msg.To]}, r.HashForID(from)) {
		fmt.Printf("Kr4 VerifyMessage() failed; failed to validate fac proof\n")
		return errors.New("failed to validate fac proof")
	}

	return nil
}

// StoreMessage implements round.Round.
//
// Since this message is only intended for us, we need to do the VSS verification here.
// - check that the decrypted share did not overflow.
// - check VSS condition.
// - save share.
func (r *Kround4) StoreMessage(msg round.Message) error {
	from, body := msg.From, msg.Content.(*Message4)

	// decrypt share
	DecryptedShare, err := r.PaillierSecret.Dec(body.Share)
	if err != nil {
		fmt.Printf("Kr4 storeMessage() failed to decrypt received share\n")
		return err
	}
	Share := r.Group().NewScalar().SetNat(DecryptedShare.Mod(r.Group().Order()))
	if DecryptedShare.Eq(curve.MakeInt(Share)) != 1 {
		fmt.Println("Kr4 storeMessage(): Decrypted share is not in correct range")
		return errors.New("decrypted share is not in correct range")
	}
	// verify share with VSS
	ExpectedPublicShare := r.VSSPolynomials[from].Evaluate(r.SelfID().Scalar(r.Group())) // Fⱼ(i)
	PublicShare := Share.ActOnBase()
	// X == Fⱼ(i)
	if !PublicShare.Equal(ExpectedPublicShare) {
		fmt.Println("Kr4 storeMessage(): Failed to validate VSS share from", from)
		return errors.New("failed to validate VSS share")
	}
	fmt.Println("Successfully validated VSS share from", from)

	r.ShareReceived[from] = Share
	return nil
}

// Finalize implements round.Round
//
// - sum of all received shares
// - compute group public key and individual public keys
// - recompute config SSID
// - validate Config
// - write new ssid hash to old hash state
// - create proof of knowledge of secret.
func (r *Kround4) Finalize(out []*round.Message) (round.Session, []*round.Message, error) {
	// add all shares to our secret
	UpdatedSecretECDSA := r.Group().NewScalar()
	if r.PreviousSecretECDSA != nil {
		UpdatedSecretECDSA.Set(r.PreviousSecretECDSA)
	}
	for _, j := range r.PartyIDs() {
		if r.ShareReceived[j] == nil {
			return r, nil, fmt.Errorf("Missing a ShareReceived[j] for party %+v\n", j)
		}
		UpdatedSecretECDSA.Add(r.ShareReceived[j])
	}

	// [F₁(X), …, Fₙ(X)]
	ShamirPublicPolynomials := make([]*polynomial.Exponent, 0, len(r.VSSPolynomials))
	for _, VSSPolynomial := range r.VSSPolynomials {
		ShamirPublicPolynomials = append(ShamirPublicPolynomials, VSSPolynomial)
	}

	// ShamirPublicPolynomial = F(X) = ∑Fⱼ(X)
	ShamirPublicPolynomial, err := polynomial.Sum(ShamirPublicPolynomials)
	if err != nil {
		return r, nil, err
	}

	// compute the new public key share Xⱼ = F(j) (+X'ⱼ if doing a refresh)
	PublicData := make(map[party.ID]*config.Public, len(r.PartyIDs()))
	for _, j := range r.PartyIDs() {
		PublicECDSAShare := ShamirPublicPolynomial.Evaluate(j.Scalar(r.Group()))
		if r.PreviousPublicSharesECDSA != nil {
			PublicECDSAShare = PublicECDSAShare.Add(r.PreviousPublicSharesECDSA[j])
		}
		PublicData[j] = &config.Public{
			ECDSA:    PublicECDSAShare,
			ElGamal:  r.ElGamalPublic[j],
			Paillier: r.PaillierPublic[j],
			Pedersen: r.Pedersen[j],
		}
	}

	UpdatedConfig := &config.Config{
		Group:     r.Group(),
		ID:        r.SelfID(),
		Threshold: r.Threshold(),
		ECDSA:     UpdatedSecretECDSA,
		ElGamal:   r.ElGamalSecret,
		Paillier:  r.PaillierSecret,
		RID:       r.RID.Copy(),
		ChainKey:  r.ChainKey.Copy(),
		Public:    PublicData,
	}
	publicPt := UpdatedConfig.PublicPoint()
	publicPt.(*curve.Secp256k1Point).ToAffine()
	compressed := publicPt.(*curve.Secp256k1Point).Compress()
	UpdatedConfig.PublicPt = compressed

	// write new ssid to hash, to bind the Schnorr proof to this new config
	// Write SSID, selfID to temporary hash
	h := r.Hash()
	_ = h.WriteAny(UpdatedConfig, r.SelfID())

	proof := r.SchnorrRand.Prove(h, PublicData[r.SelfID()].ECDSA, UpdatedSecretECDSA, nil)

	// send to all
	out = r.BroadcastMessage(out, &Broadcast5{SchnorrResponse: proof})

	r.UpdateHashState(UpdatedConfig)
	return &Kround5{
		Kround4:       r,
		UpdatedConfig: UpdatedConfig,
	}, out, nil
}

// RoundNumber implements round.Content.
func (Message4) RoundNumber() round.Number { return 4 }

// MessageContent implements round.Round.
func (Kround4) MessageContent() round.Content { return &Message4{} }

// RoundNumber implements round.Content.
func (Broadcast4) RoundNumber() round.Number { return 4 }

// BroadcastContent implements round.BroadcastRound.
func (Kround4) BroadcastContent() round.BroadcastContent { return &Broadcast4{} }

// Number implements round.Round.
func (Kround4) Number() round.Number { return 4 }

func (r Kround4) MarshalJSON() ([]byte, error) {
	mr4, e := json.Marshal(map[string]interface{}{
		"RID":      r.RID,
		"ChainKey": r.ChainKey,
	})
	if e != nil {
		fmt.Println(e)
		return nil, e
	}
	r3, e := json.Marshal(r.Kround3)
	if e != nil {
		fmt.Println(e)
		return nil, e
	}
	return jsontools.JoinJSON(mr4, r3)
}

func (r *Kround4) UnmarshalJSON(j []byte) error {
	var tmp map[string]json.RawMessage
	if err := json.Unmarshal(j, &tmp); err != nil {
		return err
	}

	var r3 Kround3
	if err := json.Unmarshal(j, &r3); err != nil {
		return err
	}

	var rid types.RID
	if err := json.Unmarshal(tmp["RID"], &rid); err != nil {
		return err
	}

	var ckey types.RID
	if err := json.Unmarshal(tmp["ChainKey"], &ckey); err != nil {
		return err
	}

	r.Kround3 = &r3
	r.RID = rid
	r.ChainKey = ckey
	return nil
}

func (m Message4) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"Share": m.Share,
		"Fac":   m.Fac,
	})
}

func (m *Message4) UnmarshalJSON(j []byte) error {
	var tmp map[string]json.RawMessage
	if e := json.Unmarshal(j, &tmp); e != nil {
		fmt.Println("Message4 unmarshal failed @ tmp:", e)
		return e
	}

	var sh *paillier.Ciphertext
	if e := json.Unmarshal(tmp["Share"], &sh); e != nil {
		fmt.Println("Message4 unmarshal failed @ Share:", e)
		return e
	}

	var fac *zkfac.Proof
	if e := json.Unmarshal(tmp["Fac"], &fac); e != nil {
		fmt.Println("Message4 unmarshal failed @ zkfac:", e)
		return e
	}

	m.Share = sh
	m.Fac = fac
	return nil
}

func (m Broadcast4) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"Mod": m.Mod,
		"Prm": m.Prm,
	})
}

func (m *Broadcast4) UnmarshalJSON(j []byte) error {
	var tmp map[string]json.RawMessage
	if e := json.Unmarshal(j, &tmp); e != nil {
		fmt.Println("Broadcast4 unmarshal failed @ tmp:", e)
		return e
	}

	var mod *zkmod.Proof
	if e := json.Unmarshal(tmp["Mod"], &mod); e != nil {
		fmt.Println("Broadcast4 unmarshal failed @ zkmod.Proof:", e)
		return e
	}

	var prm *zkprm.Proof
	if e := json.Unmarshal(tmp["Prm"], &prm); e != nil {
		fmt.Println("Broadcast4 unmarshal failed @ zkprm.Proof:", e)
		return e
	}

	m.Mod = mod
	m.Prm = prm
	return nil
}
